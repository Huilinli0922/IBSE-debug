function SC = ...
    ChannelHelmholtzSolverPre(boundary_data, diff_operators, operators)
%	ChannelHelmholtzSolverPre  preprocessing of Helmholtz solver in a
%                              channel, using Immerse Boundary Smooth
%                              Extension method.
%
%       J. Mac Huang, 06/18/2016
%       final version 06/19/2016
%       AML DT, sculpt candy project
%
%   Helmholtz equation: u - sigma*(u_xx + u_yy) = f(x,y)
%
%   Inputs:  boundary_data, diff_operators, operators generated by
%            corresponding functions
%
%   Outputs: SC           - Shur complement
%
%

% grab all the data
[X, Y, nx, ny, XE, XO] = boundary_data{:};
[Laplacian, invLaplacian, Helmholtz_Op, inv_Helmholtz_Op, inv_H, N, sigma, IBSEk] ...
                    = diff_operators{:};
[Sn, normD, S, ST, STn, T, TT, T_1, T_2, T_3, R_1, R_2, R_3, B] ...
                    = operators{:};
                
XE_all = 1-XO; nbdy = length(X); 
if IBSEk == 1
    Tn = T_1; R = R_1;
elseif IBSEk == 2
    Tn = T_2; R = R_2;
elseif IBSEk == 3
    Tn = T_3; R = R_3;
else 
    error('unknown order of IBSE')
end

% F is the singular force for the extention eqn, SC is the Schur-Complement
length_F = size(Tn,2);
SC = zeros(size(R,1) + size(B,1) +1);

% assigning 1 to each element of F, obtain all components of SC
parfor k = 1:length_F
    F = zeros(length_F,1); F(k) = 1;
    xi = operator(Tn*F, inv_H); 
    op_xi = XE_all.*operator(xi, Helmholtz_Op);
    u = operator( op_xi, inv_Helmholtz_Op);
    SC(:,k) = [R*(u-xi); B*u; sum(op_xi)/(nbdy)^2];
end

% if sigma = 0 (Poisson eqn), special cares need to be taken
SC(:,end) = [ zeros(size(R,1) + size(B,1) - (nbdy),1); ones(nbdy,1); 0]/(nbdy);
if sigma
    SC = SC(1:end-1,1:end-1);
end

end
