function [u, v, p, iter_u] = GMRES_VPSolver(boundary_data, ...
    boundary_condition_uv, diff_operators, operators, fu, fv, fp, GrandSC, gmres_tol)
%	GMRES_VPSolver  Solving NS problem in the physical domain 
%                                               with moving boundary
%
%       J. Mac Huang, 06/22/2023
%       AML DT, sculpt candy project
%
%   Stokes Problem:   Lu + p_x = XO*fu
%                     Lv + p_y = XO*fv
%                     u_x + v_y = XO*fp
%
%   Inputs:  boundary_data, diff_operators, operators, inverse of SC
%            generated by corresponding functions
%            fu, fv, fp   - driving terms defined in the equations above
%            boundary_condition_uv
%                         - boundary condition on u and v
%            GrandSC      - grand SC
%            gmres_tol    - tolerance for the gmres solver
%
%   Outputs: u, v         - flow velocity in x, y direction
%            p            - pressure (zero mean)
%            iter_u       - number of iterations in gmres
%

[u_gamma, v_gamma] = boundary_condition_uv{:};
u_BC = [u_gamma]; v_BC = [v_gamma];

% grab all the data
[X, Y, nx, ny, XE, XO] = boundary_data{:};
[Laplacian, invLaplacian, Helmholtz_Op, inv_Helmholtz_Op, inv_H, N, sigma,...
    IBSEk, dx, dy, inv_dx, inv_dy, inv_H_lower, inv_H_higher] ...
    = diff_operators{:};
[Sn, normD, S, ST, STn, T, TT, T_1, T_2, T_3, R_1, R_2, R_3, B] ...
    = operators{:};

% get all the length
nbdy = length(X);  N = sqrt(length(XO));

% get lower order TT
TT_1 = TT(1:2*nbdy,:);
TT_2 = TT(1:3*nbdy,:);

% detect the order of method
if  IBSEk ==1
    Tn = T_1; R = R_1; Tn_lower = S; TT_lower = ST;
elseif IBSEk ==2
    Tn = T_2; R = R_2; Tn_lower = T_1; TT_lower = TT_1;
elseif IBSEk == 3
    Tn = T_3; R = R_3; Tn_lower = T_2; TT_lower = TT_2;
else
    error('unknown order of IBSE')
end

% get other vector length
length_T_u = size(Tn,2);

% solve 0-Stokes problem (36a-c)
[u0, v0, p0] = StokesSolver(boundary_data, diff_operators, ...
    operators, XO.*fu, XO.*fv, XO.*fp);

% compute the RHS
RHS = [ST*u0-u_BC; ST*v0-v_BC; R*u0; R*v0; TT_lower*p0];

% compute singular force F
[F, ~, ~, iter_u] = gmres(@forward_op, RHS, 10, gmres_tol, 100, GrandSC);


% get singular force
Fu = F(1:length_T_u); Fv = F(length_T_u+1:2*length_T_u);
Fp = F(2*length_T_u+1:end);

% compute all xi values (25c-d)
xi_u = operator(-Tn*Fu, inv_H); xi_v = operator(-Tn*Fv, inv_H);
xi_p = operator(-Tn_lower*Fp, inv_H_lower);

% finally, compute u, v, p from (25a-b)
fp_new = (1-XO).*(operator(xi_u, dx)+operator(xi_v, dy)) + XO.*fp;
fu_new = (1-XO).*(operator(xi_u, Helmholtz_Op)+operator(xi_p, dx)) + XO.*fu;
fv_new = (1-XO).*(operator(xi_v, Helmholtz_Op)+operator(xi_p, dy)) + XO.*fv;
[u, v, p] = StokesSolver(boundary_data, diff_operators, operators, fu_new, fv_new, fp_new);

    function newRHST = forward_op(F)
        % forcing for omega and psi
        Fu_tmp = F(1:length_T_u); 
        Fv_tmp = F(length_T_u+1:2*length_T_u);
        Fp_tmp = F(2*length_T_u+1:end);
        
        % get xi value of u, v, p (25c-d)
        xi_u_tmp = operator(Tn*Fu_tmp, inv_H); 
        xi_v_tmp = operator(Tn*Fv_tmp, inv_H);
        xi_p_tmp = operator(Tn_lower*Fp_tmp, inv_H_lower);
        
        % compute corresponding u, v (38a-c)
        fp_tmp = (1-XO).*(operator(xi_u_tmp, dx)+operator(xi_v_tmp, dy));
        fu_tmp = (1-XO).*(operator(xi_u_tmp, Helmholtz_Op)+operator(xi_p_tmp, dx));
        fv_tmp = (1-XO).*(operator(xi_v_tmp, Helmholtz_Op)+operator(xi_p_tmp, dy));
        [u_tmp, v_tmp, p_tmp] = StokesSolver(boundary_data, diff_operators, operators, fu_tmp, fv_tmp, fp_tmp);
        
        % put in elements of grandSC
        newRHST = [ST*u_tmp; ...
            ST*v_tmp; ...
            R*(u_tmp-xi_u_tmp);...
            R*(v_tmp-xi_v_tmp);...
            TT_lower*(p_tmp-xi_p_tmp)];
    end
end
